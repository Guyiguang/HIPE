include("${CMAKE_SOURCE_DIR}/cmake/common_functions_and_macros.cmake")
include("${CMAKE_SOURCE_DIR}/cmake/boost_config.cmake")
include("${CMAKE_SOURCE_DIR}/cmake/livemedia_config.cmake")
include("${CMAKE_SOURCE_DIR}/cmake/python27_config.cmake")
include("${CMAKE_SOURCE_DIR}/cmake/opencv_config.cmake")
if(USE_DLIB)
  include("${CMAKE_SOURCE_DIR}/cmake/dlib_config.cmake")
endif(USE_DLIB)


# Generate References.h with all algorithm headers.
set(header_ref_path ${CMAKE_SOURCE_DIR}/header/filter/References.h)

# The References header includes all of the algorithm headers in the "algos"
# directory. These should be added automatically. The following commands will
# find the header files and update the References header if the content has
# changed. It is currently unused because our development environment requires
# the update to occur at build time to facilitate compilation for Visual Studio
# developers. See the commands added below to deal with the updates at build
# time.

# set(_src_filter_inc_path ${CMAKE_SOURCE_DIR}/header/filter)
# file(
#   GLOB_RECURSE algoFiles
#   LIST_DIRECTORIES false
#   RELATIVE "${_src_filter_inc_path}/algos"
#   "${_src_filter_inc_path}/algos/*.h*"
# )
# # Ensure a stable order for comparison. This is moot given that CMake's sort
# # order differs from both Bash's globbing and "sort -u"'s output. The comparison
# # file is regenerated regardless during the build process.
# list(SORT algoFiles)
# set(header_ref_content "// This file is automatically generated by CMake. Do not edit.\n#pragma once\n")
# foreach(algoFile IN ITEMS ${algoFiles})
#   message(STATUS "found algorithm header: ${algoFile}")
#   file(TO_CMAKE_PATH "${algoFile}" algoIncludePath)
#   set(header_ref_content "${header_ref_content}#include <filter/algos/${algoIncludePath}>\n")
# endforeach(algoFile IN ITEMS ${algoFiles})
#
# file(READ ${header_ref_path} old_header_ref_content)
#
# if(NOT ${header_ref_content}  STREQUAL ${old_header_ref_content})
#   message(STATUS "Updating ${header_ref_path}")
#   file(WRITE ${header_ref_path} "${header_ref_content}")
# endif(NOT ${header_ref_content}  STREQUAL ${old_header_ref_content})


add_hipe_library(filter)
target_sources(filter PUBLIC ${header_ref_path})
define_file_basename_for_sources(filter)

prepend_target_include_directories_if_necessary(filter "${OpenCV_INCLUDE_DIRS}")
prepend_target_include_directories_if_necessary(filter "${Live_INCLUDEDIR}")
if(USE_DLIB)
  prepend_target_include_directories_if_necessary(filter "${Dlib_INCLUDEDIR}")
endif(USE_DLIB)

target_compile_definitions(filter PRIVATE "-DUSE_BOOST_REGEX" "-DFILTER_BUILD")


# if(UNIX)
#   #set(MYLIBS -Wl,--whole-archive core streaming data -Wl,--no-whole-archive)
#   set(MYLIBS -Wl,--start-group core streaming data -Wl,--end-group)
# endif()
# target_link_libraries(filter -Wl,--start-group core streaming data -Wl,--end-group)
target_link_libraries(filter core corefilter data json)

target_link_libraries(filter ${Boost_LIBRARIES})
target_link_libraries(filter ${CMAKE_THREAD_LIBS_INIT})
target_link_libraries(filter ${OpenCV_LIBS} opencv_xfeatures2d)
target_link_libraries(filter ${Lives_LIBS})
target_link_libraries(filter ${Python27_LIBRARIES} )
if(USE_DLIB)
  # TODO
  # Check this. The original file used the conditionals below but surely this
  # is platform-independant, no?
  target_link_libraries(filter ${Dlib_LIBRARIES})
#   if(WIN32)
#     target_link_libraries(filter ${Dlib_LIBRARIES})
#
#     #set(BLAS_openblas_LIBRARY ${HIPE_EXTERNAL}/OpenBLAS/)
#     #find_package(BLAS REQUIRED)
#
#   elseif(UNIX)
#     target_link_libraries(filter ${Dlib_LIBRARIES})
#   endif(WIN32)
endif(USE_DLIB)

# Configure Visual Studio to handle more options.
if(WIN32)
  target_compile_options(filter PRIVATE /bigobj)
endif(WIN32)


# Enable the addition of algorithms without forcing a rerun of CMake
if(WIN32)
  set(script_path "${CMAKE_SOURCE_DIR}/scripts/headerList.bat")
  set(script_compy "${CMAKE_SOURCE_DIR}/scripts/compy.bat")
  file(TO_NATIVE_PATH "${script_compy}" os_path)
  set(script_compy ${os_path})
  add_custom_command(
    TARGET filter
    PRE_BUILD
    COMMAND cmd /c echo \#pragma once > "${os_ref_header_path}.cmp"
    COMMAND cmd /c echo ^// Algorithm header to reference  >> \"${os_ref_header_path}.cmp\"
    COMMAND cmd /c "${script_path}" "filter/algos" >> \"${os_ref_header_path}.cmp\"
    COMMAND cmd /c "${script_compy}" \"${os_ref_header_path}.cmp\" \"${os_ref_header_path}\"
    COMMENT "Generate reference file"
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/header/filter/algos
  )
endif(WIN32)

if(UNIX)
  set(script_path "${CMAKE_SOURCE_DIR}/scripts/generate_References_header.sh")
  add_custom_target(
    update_reference
    COMMAND echo "Collect algorithm headers in ${header_ref_path}"
    WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}/header/filter/algos"
  )

  add_custom_command(
    TARGET update_reference
    POST_BUILD
    COMMAND bash "${script_path}" "${header_ref_path}"
    COMMENT "Generate reference file"
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/header/filter
  )
  add_dependencies(filter update_reference)
endif(UNIX)



if(WIN32) #TODO: Is MSYS true when MSVC is true?
  message(STATUS "Test if it works with windows")
  target_link_libraries(filter ws2_32 wsock32)
endif(WIN32)

display_target_properties(filter)
